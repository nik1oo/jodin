[INFO ] --- [2025-07-28 17:15:25] Starting test runner with 1 thread.
[INFO ] --- [2025-07-28 17:15:25] The random seed sent to every test is: 151769983510770. Set with -define:ODIN_TEST_RANDOM_SEED=n.
[INFO ] --- [2025-07-28 17:15:25] Memory tracking is enabled. Tests will log their memory usage if there's an issue.
[INFO ] --- [2025-07-28 17:15:25] < Final Mem/ Total Mem> <  Peak Mem> (#Free/Alloc) :: [package.test_name]
[INFO ] --- [2025-07-28 17:15:25] [test_notebooks.odin:38:test_notebook()] Started session.
[INFO ] --- [2025-07-28 17:15:25] [test_notebooks.odin:42:test_notebook()] Filepath: examples/demo.ipynb
[1;34m[CellContent]----------------------------------------
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_25_2
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
}
exit:: proc() { __cell__.session.exit = true }

@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
if len(os.args) == 1 {
    fmt.printf("Hellope from %v.\n", os.args[0])
} else if len(os.args) > 2 {
    fmt.printf("%v, %v! from %v.\n", os.args[1], os.args[2], os.args[0])
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_26_4
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
}
exit:: proc() { __cell__.session.exit = true }


@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	if len(os.args) == 1 {
    fmt.printf("Hellope from %v.\n", os.args[0])
} else if len(os.args) > 2 {
    fmt.printf("%v, %v! from %v.\n", os.args[1], os.args[2], os.args[0])
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
// A comment

my_integer_variable: int // A comment for documentaton
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_26_6
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
my_integer_variable: int
@(export) __update_symmap__:: proc() {
__symmap__["my_integer_variable"] = auto_cast &my_integer_variable
}
@(export) __apply_symmap__:: proc() {
}
exit:: proc() { __cell__.session.exit = true }



@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
/*
	You can have any text or code here and
	have it be commented.
	/*
		NOTE: comments can be nested!
	*/
*/
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_26_8
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
my_integer_variable: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
}
exit:: proc() { __cell__.session.exit = true }




@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
some_string : string = "This is a string"
_ = 'A' // unicode codepoint literal
_ = '\n'
_ = "C:\\Windows\\notepad.exe"
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_27_10
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
my_integer_variable: ^int
some_string: string
@(export) __update_symmap__:: proc() {
__symmap__["some_string"] = auto_cast &some_string
}
@(export) __apply_symmap__:: proc() {
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
}
exit:: proc() { __cell__.session.exit = true }





@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	some_string = "This is a string"
	 _ = 'A'
	 _ = '\n'
	 _ = "C:\\Windows\\notepad.exe"
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
_ = `C:\Windows\notepad.exe`
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_27_12
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
my_integer_variable: ^int
some_string: ^string
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_string = (cast(^string)__symmap__["some_string"])
}
exit:: proc() { __cell__.session.exit = true }






@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 _ = `C:\Windows\notepad.exe`
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
_ = len("Foo")
_ = len(some_string)
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_27_14
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
my_integer_variable: ^int
some_string: ^string
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_string = (cast(^string)__symmap__["some_string"])
}
exit:: proc() { __cell__.session.exit = true }







@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 _ = len("Foo")
	 _ = len(some_string^)
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
x: int = 1.0 // A float literal but it can be represented by an integer without precision loss
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_28_16
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_string: ^string
my_integer_variable: ^int
x: int
@(export) __update_symmap__:: proc() {
__symmap__["x"] = auto_cast &x
}
@(export) __apply_symmap__:: proc() {
some_string = (cast(^string)__symmap__["some_string"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
}
exit:: proc() { __cell__.session.exit = true }








@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	x = 1.0
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
y: int // `y` is typed of type `int`
y = 1  // `1` is an untyped integer literal which can implicitly convert to `int`

z: f64 // `z` is typed of type `f64` (64-bit floating point number)
z = 1  // `1` is an untyped integer literal which can be implicitly converted to `f64`
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_28_18
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_string: ^string
my_integer_variable: ^int
x: ^int
y: int
z: f64
@(export) __update_symmap__:: proc() {
__symmap__["y"] = auto_cast &y
__symmap__["z"] = auto_cast &z
}
@(export) __apply_symmap__:: proc() {
some_string = (cast(^string)__symmap__["some_string"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
x = (cast(^int)__symmap__["x"])
}
exit:: proc() { __cell__.session.exit = true }









@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 y = 1
	 z = 1
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
h: int = 123 // declares a new variable `h` with type `int` and assigns a value to it
h = 637 // assigns a new value to `h`
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_28_21
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_string: ^string
y: ^int
z: ^f64
my_integer_variable: ^int
x: ^int
h: int
@(export) __update_symmap__:: proc() {
__symmap__["h"] = auto_cast &h
}
@(export) __apply_symmap__:: proc() {
some_string = (cast(^string)__symmap__["some_string"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
x = (cast(^int)__symmap__["x"])
}
exit:: proc() { __cell__.session.exit = true }










@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	h = 123
	 h = 637
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
a, b : string = "1", "hello"
b, a = "byte", "0"
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_29_23
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_string: ^string
y: ^int
z: ^f64
h: ^int
my_integer_variable: ^int
x: ^int
a: string
b: string
@(export) __update_symmap__:: proc() {
__symmap__["a"] = auto_cast &a
__symmap__["b"] = auto_cast &b
}
@(export) __apply_symmap__:: proc() {
some_string = (cast(^string)__symmap__["some_string"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
h = (cast(^int)__symmap__["h"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
x = (cast(^int)__symmap__["x"])
}
exit:: proc() { __cell__.session.exit = true }











@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	a = "1"
	b = "hello"
	 b, a = "byte", "0"
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
X :: "what" // constant `X` has the untyped string value "what"
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_29_26
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_string: ^string
y: ^int
z: ^f64
h: ^int
a: ^string
b: ^string
my_integer_variable: ^int
x: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
some_string = (cast(^string)__symmap__["some_string"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
x = (cast(^int)__symmap__["x"])
}
exit:: proc() { __cell__.session.exit = true }











X :: "what"

@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
Y : int : 123
Z :: Y + 7 // constant computations are possible
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_30_28
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_string: ^string
y: ^int
z: ^f64
h: ^int
a: ^string
b: ^string
my_integer_variable: ^int
x: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
some_string = (cast(^string)__symmap__["some_string"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
x = (cast(^int)__symmap__["x"])
}
exit:: proc() { __cell__.session.exit = true }











X :: "what"

Y : int : 123
Z :: Y + 7

@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
_ = my_integer_variable
_ = x
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_30_29
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
y: ^int
z: ^f64
some_string: ^string
a: ^string
b: ^string
x: ^int
h: ^int
my_integer_variable: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_string = (cast(^string)__symmap__["some_string"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
h = (cast(^int)__symmap__["h"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
}
exit:: proc() { __cell__.session.exit = true }






Y : int : 123
Z :: Y + 7



X :: "what"





@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 _ = my_integer_variable^
	 _ = x^
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
for i := 0; i < 10; i += 1 {
    fmt.println(i)
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_30_32
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
y: ^int
z: ^f64
some_string: ^string
a: ^string
b: ^string
x: ^int
h: ^int
my_integer_variable: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_string = (cast(^string)__symmap__["some_string"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
h = (cast(^int)__symmap__["h"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
}
exit:: proc() { __cell__.session.exit = true }






Y : int : 123
Z :: Y + 7



X :: "what"






@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
		for i := 0; i < 10; i += 1 {
{
    fmt.println(i)
}
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
for i := 0; i < 10; i += 1 { }
for i := 0; i < 10; i += 1 do fmt.print()
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_30_34
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
y: ^int
z: ^f64
some_string: ^string
a: ^string
b: ^string
x: ^int
h: ^int
my_integer_variable: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_string = (cast(^string)__symmap__["some_string"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
h = (cast(^int)__symmap__["h"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
}
exit:: proc() { __cell__.session.exit = true }







Y : int : 123
Z :: Y + 7



X :: "what"






@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
		for i := 0; i < 10; i += 1 {
{ }
	}
		for i := 0; i < 10; i += 1 {
fmt.print()
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
i : int = 0
for ; i < 10; {
    i += 1
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_31_36
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
y: ^int
z: ^f64
some_string: ^string
a: ^string
b: ^string
x: ^int
h: ^int
my_integer_variable: ^int
i: int
@(export) __update_symmap__:: proc() {
__symmap__["i"] = auto_cast &i
}
@(export) __apply_symmap__:: proc() {
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_string = (cast(^string)__symmap__["some_string"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
h = (cast(^int)__symmap__["h"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
}
exit:: proc() { __cell__.session.exit = true }







Y : int : 123
Z :: Y + 7




X :: "what"






@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	i = 0
		for ; i < 10;  {
{
    i += 1
}
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
k: int = 1
for k < 9 {
    k += 1
    fmt.println(k)
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_31_38
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
y: ^int
z: ^f64
some_string: ^string
a: ^string
b: ^string
x: ^int
h: ^int
i: ^int
my_integer_variable: ^int
k: int
@(export) __update_symmap__:: proc() {
__symmap__["k"] = auto_cast &k
}
@(export) __apply_symmap__:: proc() {
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_string = (cast(^string)__symmap__["some_string"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
h = (cast(^int)__symmap__["h"])
i = (cast(^int)__symmap__["i"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
}
exit:: proc() { __cell__.session.exit = true }







Y : int : 123
Z :: Y + 7





X :: "what"






@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	k = 1
		for ; k < 9;  {
{
    k += 1
    fmt.println(k)
}
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
i = 0
for i < 10 {
    i += 1
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_32_39
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
y: ^int
z: ^f64
some_string: ^string
a: ^string
b: ^string
x: ^int
h: ^int
i: ^int
k: ^int
my_integer_variable: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_string = (cast(^string)__symmap__["some_string"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
h = (cast(^int)__symmap__["h"])
i = (cast(^int)__symmap__["i"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
}
exit:: proc() { __cell__.session.exit = true }







Y : int : 123
Z :: Y + 7





X :: "what"







@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 i^ = 0
		for ; i^ < 10;  {
{
	    i^ += 1
	}
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
for {
    break
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_32_41
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
y: ^int
z: ^f64
some_string: ^string
a: ^string
b: ^string
x: ^int
h: ^int
i: ^int
k: ^int
my_integer_variable: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_string = (cast(^string)__symmap__["some_string"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
h = (cast(^int)__symmap__["h"])
i = (cast(^int)__symmap__["i"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
}
exit:: proc() { __cell__.session.exit = true }








Y : int : 123
Z :: Y + 7





X :: "what"







@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
		for ; ;  {
{
    break
}
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
for j := 0; j < 10; j += 1 {
    fmt.println(j)
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_32_43
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
y: ^int
z: ^f64
some_string: ^string
a: ^string
b: ^string
x: ^int
h: ^int
i: ^int
k: ^int
my_integer_variable: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_string = (cast(^string)__symmap__["some_string"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
h = (cast(^int)__symmap__["h"])
i = (cast(^int)__symmap__["i"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
}
exit:: proc() { __cell__.session.exit = true }









Y : int : 123
Z :: Y + 7





X :: "what"







@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
		for j := 0; j < 10; j += 1 {
{
    fmt.println(j)
}
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
for j in 0..<10 {
    fmt.println(j)
}
for j in 0..=9 {
    fmt.println(j)
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_33_45
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
my_integer_variable: ^int
y: ^int
z: ^f64
some_string: ^string
a: ^string
b: ^string
x: ^int
h: ^int
i: ^int
k: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_string = (cast(^string)__symmap__["some_string"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
h = (cast(^int)__symmap__["h"])
i = (cast(^int)__symmap__["i"])
k = (cast(^int)__symmap__["k"])
}
exit:: proc() { __cell__.session.exit = true }










Y : int : 123
Z :: Y + 7





X :: "what"







@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	for j in 0..<10 {
    fmt.println(j)
}
	for j in 0..=9 {
    fmt.println(j)
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
some_string = "Hello, 世界"
for character in some_string { // Strings are assumed to be UTF-8
    fmt.println(character)
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_33_47
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
my_integer_variable: ^int
y: ^int
z: ^f64
some_string: ^string
a: ^string
b: ^string
x: ^int
h: ^int
i: ^int
k: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_string = (cast(^string)__symmap__["some_string"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
h = (cast(^int)__symmap__["h"])
i = (cast(^int)__symmap__["i"])
k = (cast(^int)__symmap__["k"])
}
exit:: proc() { __cell__.session.exit = true }










Y : int : 123
Z :: Y + 7






X :: "what"







@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 some_string^ = "Hello, 世界"
	for character in some_string^ { // Strings are assumed to be UTF-8
	    fmt.println(character)
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
some_array : [3]int = [3]int{1, 4, 9}
for value in some_array {
    fmt.println(value)
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_34_48
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
my_integer_variable: ^int
y: ^int
z: ^f64
some_string: ^string
a: ^string
b: ^string
x: ^int
h: ^int
i: ^int
k: ^int
some_array: [3]int
@(export) __update_symmap__:: proc() {
__symmap__["some_array"] = auto_cast &some_array
}
@(export) __apply_symmap__:: proc() {
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_string = (cast(^string)__symmap__["some_string"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
h = (cast(^int)__symmap__["h"])
i = (cast(^int)__symmap__["i"])
k = (cast(^int)__symmap__["k"])
}
exit:: proc() { __cell__.session.exit = true }










Y : int : 123
Z :: Y + 7







X :: "what"







@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	some_array = [3]int{1, 4, 9}
	for value in some_array {
    fmt.println(value)
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
some_slice : []int = []int{1, 4, 9}
for value in some_slice {
    fmt.println(value)
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_34_49
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
my_integer_variable: ^int
y: ^int
z: ^f64
some_string: ^string
a: ^string
b: ^string
x: ^int
h: ^int
i: ^int
some_array: ^[3]int
k: ^int
some_slice: []int
@(export) __update_symmap__:: proc() {
__symmap__["some_slice"] = auto_cast &some_slice
}
@(export) __apply_symmap__:: proc() {
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_string = (cast(^string)__symmap__["some_string"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
h = (cast(^int)__symmap__["h"])
i = (cast(^int)__symmap__["i"])
some_array = (cast(^[3]int)__symmap__["some_array"])
k = (cast(^int)__symmap__["k"])
}
exit:: proc() { __cell__.session.exit = true }










Y : int : 123
Z :: Y + 7







X :: "what"








@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	some_slice = []int{1, 4, 9}
	for value in some_slice {
    fmt.println(value)
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
#+feature dynamic-literals
some_dynamic_array : [dynamic]int = [dynamic]int{1, 4, 9}
defer delete(some_dynamic_array)
for value in some_dynamic_array {
    fmt.println(value)
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------
#+feature dynamic-literals

package cell_17_15_34_50
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
some_dynamic_array: [dynamic]int
@(export) __update_symmap__:: proc() {
__symmap__["some_dynamic_array"] = auto_cast &some_dynamic_array
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
}
exit:: proc() { __cell__.session.exit = true }


Y : int : 123
Z :: Y + 7


X :: "what"






















@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	some_dynamic_array = [dynamic]int{1, 4, 9}
	 defer delete(some_dynamic_array)
	for value in some_dynamic_array {
    fmt.println(value)
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
#+feature dynamic-literals
some_map : map[string]int = map[string]int{"A" = 1, "C" = 9, "B" = 4}
defer delete(some_map)
for key in some_map {
    fmt.println(key)
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------
#+feature dynamic-literals

package cell_17_15_35_51
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
some_map: map[string]int
@(export) __update_symmap__:: proc() {
__symmap__["some_map"] = auto_cast &some_map
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
}
exit:: proc() { __cell__.session.exit = true }


Y : int : 123
Z :: Y + 7


X :: "what"























@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	some_map = map[string]int{"A" = 1, "C" = 9, "B" = 4}
	 defer delete(some_map)
	for key in some_map {
    fmt.println(key)
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
for character, index in some_string {
    fmt.println(index, character)
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_35_53
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
}
exit:: proc() { __cell__.session.exit = true }


Y : int : 123
Z :: Y + 7


X :: "what"
























@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	for character, index in some_string^ {
	    fmt.println(index, character)
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
for value, index in some_array {
    fmt.println(index, value)
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_35_54
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
}
exit:: proc() { __cell__.session.exit = true }


Y : int : 123
Z :: Y + 7


X :: "what"

























@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	for value, index in some_array^ {
	    fmt.println(index, value)
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
for value, index in some_slice {
    fmt.println(index, value)
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_36_55
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
}
exit:: proc() { __cell__.session.exit = true }


Y : int : 123
Z :: Y + 7


X :: "what"


























@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	for value, index in some_slice^ {
	    fmt.println(index, value)
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
for value, index in some_dynamic_array {
    fmt.println(index, value)
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_36_56
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
}
exit:: proc() { __cell__.session.exit = true }


Y : int : 123
Z :: Y + 7


X :: "what"



























@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	for value, index in some_dynamic_array^ {
	    fmt.println(index, value)
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
for key, value in some_map {
    fmt.println(key, value)
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_36_57
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
}
exit:: proc() { __cell__.session.exit = true }


Y : int : 123
Z :: Y + 7


X :: "what"




























@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	for key, value in some_map^ {
	    fmt.println(key, value)
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
for _, idx in some_slice {
    some_slice[idx] = (idx+1)*(idx+1)
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_37_59
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
}
exit:: proc() { __cell__.session.exit = true }


Y : int : 123
Z :: Y + 7


X :: "what"





























@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	for _, idx in some_slice^ {
	    some_slice^[idx] = (idx+1)*(idx+1)
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
x = 123
if x >= 0 {
    fmt.println("x is positive")
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_37_61
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
}
exit:: proc() { __cell__.session.exit = true }


Y : int : 123
Z :: Y + 7


X :: "what"






























@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 x^ = 123
	if x^ >= 0 {
	    fmt.println("x is positive")
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
if y := -34; y < 0 {
    fmt.println("y is negative")
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_38_62
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
}
exit:: proc() { __cell__.session.exit = true }


Y : int : 123
Z :: Y + 7


X :: "what"































@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	if y := -34; y < 0 {
    fmt.println("y is negative")
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
if y := 123; y < 0 {
    fmt.println("y is negative")
} else if y == 0 {
    fmt.println("y is zero")
} else {
    fmt.println("y is positive")
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_38_63
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
}
exit:: proc() { __cell__.session.exit = true }


Y : int : 123
Z :: Y + 7


X :: "what"
































@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	if y := 123; y < 0 {
    fmt.println("y is negative")
} else if y == 0 {
    fmt.println("y is zero")
} else {
    fmt.println("y is positive")
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
#partial switch arch := ODIN_ARCH; arch {
case .i386:
    fmt.println("32-bit")
case .amd64:
    fmt.println("64-bit")
case: // default
    fmt.println("Unsupported architecture")
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_38_65
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
}
exit:: proc() { __cell__.session.exit = true }


Y : int : 123
Z :: Y + 7


X :: "what"

































@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 #partial switch arch := ODIN_ARCH; arch {
case .i386:
    fmt.println("32-bit")
case .amd64:
    fmt.println("64-bit")
case: // default
    fmt.println("Unsupported architecture")
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
one_angry_dwarf :: proc() -> int {
    fmt.println("one_angry_dwarf was called")
    return 1
}

switch j := 0; j {
case 0:
case one_angry_dwarf():
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_39_67
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
@(export) one_angry_dwarf :: proc() -> int {
    fmt.println("one_angry_dwarf was called")
    return 1
}
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
}
exit:: proc() { __cell__.session.exit = true }



Y : int : 123
Z :: Y + 7


X :: "what"

































@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 switch j := 0; j {
case 0:
case one_angry_dwarf():
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
switch {
case x < 0:
    fmt.println("x is negative")
case x == 0:
    fmt.println("x is zero")
case:
    fmt.println("x is positive")
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_39_69
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
one_angry_dwarf : proc() -> int = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
}
exit:: proc() { __cell__.session.exit = true }



Y : int : 123
Z :: Y + 7


X :: "what"


































@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 switch {
	case x^ < 0:
	    fmt.println("x is negative")
	case x^ == 0:
	    fmt.println("x is zero")
	case:
	    fmt.println("x is positive")
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
switch c := 'j'; c {
case 'A'..='Z', 'a'..='z', '0'..='9':
    fmt.println("c is alphanumeric")
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_39_71
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
one_angry_dwarf : proc() -> int = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
}
exit:: proc() { __cell__.session.exit = true }




Y : int : 123
Z :: Y + 7


X :: "what"


































@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 switch c := 'j'; c {
case 'A'..='Z', 'a'..='z', '0'..='9':
    fmt.println("c is alphanumeric")
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
switch x {
case 0..<10:
    fmt.println("units")
case 10..<13:
    fmt.println("pre-teens")
case 13..<20:
    fmt.println("teens")
case 20..<30:
    fmt.println("twenties")
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_40_72
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
one_angry_dwarf : proc() -> int = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
}
exit:: proc() { __cell__.session.exit = true }




Y : int : 123
Z :: Y + 7


X :: "what"



































@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 switch x^ {
	case 0..<10:
	    fmt.println("units")
	case 10..<13:
	    fmt.println("pre-teens")
	case 13..<20:
	    fmt.println("teens")
	case 20..<30:
	    fmt.println("twenties")
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
{
    x := 123
    defer fmt.println(x)
    {
        defer x = 4
        x = 2
    }
    fmt.println(x)

    x = 234
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_40_74
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
one_angry_dwarf : proc() -> int = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
}
exit:: proc() { __cell__.session.exit = true }




Y : int : 123
Z :: Y + 7


X :: "what"




































@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	{
    x := 123
    defer fmt.println(x)
    {
        defer x = 4
        x = 2
    }
    fmt.println(x)

    x = 234
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
{
    bar :: proc() {}

    defer {
        fmt.println("1")
        fmt.println("2")
    }

    cond := false
    defer if cond {
        bar()
    }
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_40_76
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
one_angry_dwarf : proc() -> int = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
}
exit:: proc() { __cell__.session.exit = true }





Y : int : 123
Z :: Y + 7


X :: "what"




































@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	{
    bar :: proc() {}

    defer {
        fmt.println("1")
        fmt.println("2")
    }

    cond := false
    defer if cond {
        bar()
    }
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
{
    defer fmt.println("1")
    defer fmt.println("2")
    defer fmt.println("3")
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_41_78
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
one_angry_dwarf : proc() -> int = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
}
exit:: proc() { __cell__.session.exit = true }





Y : int : 123
Z :: Y + 7


X :: "what"





































@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	{
    defer fmt.println("1")
    defer fmt.println("2")
    defer fmt.println("3")
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
if false {
    f, err := os.open("my_file.txt")
    if err != nil {
        // handle error
    }
    defer os.close(f)
    // rest of code
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_41_80
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
one_angry_dwarf : proc() -> int = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
}
exit:: proc() { __cell__.session.exit = true }





Y : int : 123
Z :: Y + 7


X :: "what"






































@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	if false {
    f, err := os.open("my_file.txt")
    if err != nil {
        // handle error
    }
    defer os.close(f)
    // rest of code
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
when ODIN_ARCH == .i386 {
    fmt.println("32 bit")
} else when ODIN_ARCH == .amd64 {
    fmt.println("64 bit")
} else {
    fmt.println("Unknown architecture")
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_41_82
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
one_angry_dwarf : proc() -> int = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
}
exit:: proc() { __cell__.session.exit = true }





Y : int : 123
Z :: Y + 7


X :: "what"







































@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 when ODIN_ARCH == .i386 {
    fmt.println("32 bit")
} else when ODIN_ARCH == .amd64 {
    fmt.println("64 bit")
} else {
    fmt.println("Unknown architecture")
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
cond, cond1, cond2 : bool = true, true, false
one_step :: proc() { fmt.println("one_step") }
beyond :: proc() { fmt.println("beyond") }
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_42_85
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
some_slice: ^[]int
h: ^int
cond: bool
cond1: bool
cond2: bool
one_angry_dwarf : proc() -> int = nil
@(export) one_step :: proc() { fmt.println("one_step") }
@(export) beyond :: proc() { fmt.println("beyond") }
@(export) __update_symmap__:: proc() {
__symmap__["cond"] = auto_cast &cond
__symmap__["cond1"] = auto_cast &cond1
__symmap__["cond2"] = auto_cast &cond2
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
}
exit:: proc() { __cell__.session.exit = true }





Y : int : 123
Z :: Y + 7


X :: "what"








































@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	cond = true
	cond1 = true
	cond2 = false
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
for cond {
    switch {
    case:
        if cond {
            break // break out of the `switch` statement
        }
    }

    break // break out of the `for` statement
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_42_87
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
cond: ^bool
cond1: ^bool
cond2: ^bool
some_slice: ^[]int
h: ^int
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }





Y : int : 123
Z :: Y + 7


X :: "what"









































@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
		for ; cond^;  {
{
	    switch {
	    case:
	        if cond^ {
	            break // break out of the `switch` statement
	        }
	    }
	
	    break // break out of the `for` statement
	}
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
loop: for cond1 {
    for cond2 {
        break loop // leaves both loops
    }
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_43_88
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
i: ^int
a: ^string
b: ^string
x: ^int
some_array: ^[3]int
some_string: ^string
k: ^int
my_integer_variable: ^int
some_map: ^map[string]int
some_dynamic_array: ^[dynamic]int
y: ^int
z: ^f64
cond: ^bool
cond1: ^bool
cond2: ^bool
some_slice: ^[]int
h: ^int
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
i = (cast(^int)__symmap__["i"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
x = (cast(^int)__symmap__["x"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_string = (cast(^string)__symmap__["some_string"])
k = (cast(^int)__symmap__["k"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
h = (cast(^int)__symmap__["h"])
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }





Y : int : 123
Z :: Y + 7


X :: "what"










































@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	loop: 	for ; cond1^;  {
{
	    for cond2^ {
	        break loop // leaves both loops
	    }
	}
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
for cond {
    if cond2 {
        continue
    }
    fmt.println("Hellope")
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_43_90
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_dynamic_array: ^[dynamic]int
h: ^int
a: ^string
b: ^string
y: ^int
z: ^f64
some_array: ^[3]int
some_slice: ^[]int
some_map: ^map[string]int
some_string: ^string
x: ^int
my_integer_variable: ^int
cond: ^bool
cond1: ^bool
cond2: ^bool
k: ^int
i: ^int
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_string = (cast(^string)__symmap__["some_string"])
x = (cast(^int)__symmap__["x"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
k = (cast(^int)__symmap__["k"])
i = (cast(^int)__symmap__["i"])
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }











Y : int : 123
Z :: Y + 7




















X :: "what"



















@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
		for ; cond^;  {
{
	    if cond2^ {
	        continue
	    }
	    fmt.println("Hellope")
	}
	}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
switch i := 0; i {
case 0:
    one_step()
    fallthrough
case 1:
    beyond()
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_43_92
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_dynamic_array: ^[dynamic]int
h: ^int
a: ^string
b: ^string
y: ^int
z: ^f64
some_array: ^[3]int
some_slice: ^[]int
some_map: ^map[string]int
some_string: ^string
x: ^int
my_integer_variable: ^int
cond: ^bool
cond1: ^bool
cond2: ^bool
k: ^int
i: ^int
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_string = (cast(^string)__symmap__["some_string"])
x = (cast(^int)__symmap__["x"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
k = (cast(^int)__symmap__["k"])
i = (cast(^int)__symmap__["i"])
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }











Y : int : 123
Z :: Y + 7




















X :: "what"




















@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 switch i := 0; i {
case 0:
    one_step()
    fallthrough
case 1:
    beyond()
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
foo0 :: proc() -> int {
    return 123
}
foo1 :: proc() -> (a: int) {
    a = 123
    return
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_44_94
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_dynamic_array: ^[dynamic]int
h: ^int
a: ^string
b: ^string
y: ^int
z: ^f64
some_array: ^[3]int
some_slice: ^[]int
some_map: ^map[string]int
some_string: ^string
x: ^int
my_integer_variable: ^int
cond: ^bool
cond1: ^bool
cond2: ^bool
k: ^int
i: ^int
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) foo0 :: proc() -> int {
    return 123
}
@(export) foo1 :: proc() -> (a: int) {
    a = 123
    return
}
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_string = (cast(^string)__symmap__["some_string"])
x = (cast(^int)__symmap__["x"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
k = (cast(^int)__symmap__["k"])
i = (cast(^int)__symmap__["i"])
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }











Y : int : 123
Z :: Y + 7




















X :: "what"





















@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
foo2 :: proc() -> (a, b: int) {
    a = 321
    b = 567
    return b, a
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_44_96
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_dynamic_array: ^[dynamic]int
h: ^int
a: ^string
b: ^string
y: ^int
z: ^f64
some_array: ^[3]int
some_slice: ^[]int
some_map: ^map[string]int
some_string: ^string
x: ^int
my_integer_variable: ^int
cond: ^bool
cond1: ^bool
cond2: ^bool
k: ^int
i: ^int
foo0 : proc() -> int = nil
foo1 : proc() -> (a: int) = nil
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) foo2 :: proc() -> (a, b: int) {
    a = 321
    b = 567
    return b, a
}
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_string = (cast(^string)__symmap__["some_string"])
x = (cast(^int)__symmap__["x"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
k = (cast(^int)__symmap__["k"])
i = (cast(^int)__symmap__["i"])
foo0 = auto_cast __symmap__["foo0"]
foo1 = auto_cast __symmap__["foo1"]
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }











Y : int : 123
Z :: Y + 7





















X :: "what"





















@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
fmt.println("foo0 =", foo0())
fmt.println("foo1 =", foo1())
fmt.println("foo2 =", foo2())
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_44_97
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_dynamic_array: ^[dynamic]int
h: ^int
a: ^string
b: ^string
y: ^int
z: ^f64
some_array: ^[3]int
some_slice: ^[]int
some_map: ^map[string]int
some_string: ^string
x: ^int
my_integer_variable: ^int
cond: ^bool
cond1: ^bool
cond2: ^bool
k: ^int
i: ^int
foo0 : proc() -> int = nil
foo1 : proc() -> (a: int) = nil
foo2 : proc() -> (a, b: int) = nil
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_string = (cast(^string)__symmap__["some_string"])
x = (cast(^int)__symmap__["x"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
k = (cast(^int)__symmap__["k"])
i = (cast(^int)__symmap__["i"])
foo0 = auto_cast __symmap__["foo0"]
foo1 = auto_cast __symmap__["foo1"]
foo2 = auto_cast __symmap__["foo2"]
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }











Y : int : 123
Z :: Y + 7






















X :: "what"





















@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 fmt.println("foo0 =", foo0())
	 fmt.println("foo1 =", foo1())
	 fmt.println("foo2 =", foo2())
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
sum :: proc(nums: ..int, init_value:= 0) -> (result: int) {
    result = init_value
    for n in nums {
        result += n
    }
    return
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_45_99
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_dynamic_array: ^[dynamic]int
h: ^int
a: ^string
b: ^string
y: ^int
z: ^f64
some_array: ^[3]int
some_slice: ^[]int
some_map: ^map[string]int
some_string: ^string
x: ^int
my_integer_variable: ^int
cond: ^bool
cond1: ^bool
cond2: ^bool
k: ^int
i: ^int
foo0 : proc() -> int = nil
foo1 : proc() -> (a: int) = nil
foo2 : proc() -> (a, b: int) = nil
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) sum :: proc(nums: ..int, init_value:= 0) -> (result: int) {
    result = init_value
    for n in nums {
        result += n
    }
    return
}
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_string = (cast(^string)__symmap__["some_string"])
x = (cast(^int)__symmap__["x"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
k = (cast(^int)__symmap__["k"])
i = (cast(^int)__symmap__["i"])
foo0 = auto_cast __symmap__["foo0"]
foo1 = auto_cast __symmap__["foo1"]
foo2 = auto_cast __symmap__["foo2"]
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }











Y : int : 123
Z :: Y + 7























X :: "what"





















@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
fmt.println("sum(()) =", sum())
fmt.println("sum(1, 2) =", sum(1, 2))
fmt.println("sum(1, 2, 3, 4, 5) =", sum(1, 2, 3, 4, 5))
fmt.println("sum(1, 2, 3, 4, 5, init_value = 5) =", sum(1, 2, 3, 4, 5, init_value = 5))
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_45_100
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_dynamic_array: ^[dynamic]int
h: ^int
a: ^string
b: ^string
y: ^int
z: ^f64
some_array: ^[3]int
some_slice: ^[]int
some_map: ^map[string]int
some_string: ^string
x: ^int
my_integer_variable: ^int
cond: ^bool
cond1: ^bool
cond2: ^bool
k: ^int
i: ^int
sum : proc(nums: ..int, init_value:= 0) -> (result: int) = nil
foo0 : proc() -> int = nil
foo1 : proc() -> (a: int) = nil
foo2 : proc() -> (a, b: int) = nil
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_string = (cast(^string)__symmap__["some_string"])
x = (cast(^int)__symmap__["x"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
k = (cast(^int)__symmap__["k"])
i = (cast(^int)__symmap__["i"])
sum = auto_cast __symmap__["sum"]
foo0 = auto_cast __symmap__["foo0"]
foo1 = auto_cast __symmap__["foo1"]
foo2 = auto_cast __symmap__["foo2"]
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }











Y : int : 123
Z :: Y + 7
























X :: "what"





















@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 fmt.println("sum(()) =", sum())
	 fmt.println("sum(1, 2) =", sum(1, 2))
	 fmt.println("sum(1, 2, 3, 4, 5) =", sum(1, 2, 3, 4, 5))
	 fmt.println("sum(1, 2, 3, 4, 5, init_value = 5) =", sum(1, 2, 3, 4, 5, init_value = 5))
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
odds : []int = []int{1, 3, 5}
fmt.println("odds =", odds)
fmt.println("sum(..odds) =", sum(..odds))
fmt.println("sum(..odds, init_value = 5) =", sum(..odds, init_value = 5))
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_46_102
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_dynamic_array: ^[dynamic]int
h: ^int
a: ^string
b: ^string
y: ^int
z: ^f64
some_array: ^[3]int
some_slice: ^[]int
some_map: ^map[string]int
some_string: ^string
x: ^int
my_integer_variable: ^int
cond: ^bool
cond1: ^bool
cond2: ^bool
k: ^int
i: ^int
odds: []int
sum : proc(nums: ..int, init_value:= 0) -> (result: int) = nil
foo0 : proc() -> int = nil
foo1 : proc() -> (a: int) = nil
foo2 : proc() -> (a, b: int) = nil
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) __update_symmap__:: proc() {
__symmap__["odds"] = auto_cast &odds
}
@(export) __apply_symmap__:: proc() {
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_string = (cast(^string)__symmap__["some_string"])
x = (cast(^int)__symmap__["x"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
k = (cast(^int)__symmap__["k"])
i = (cast(^int)__symmap__["i"])
sum = auto_cast __symmap__["sum"]
foo0 = auto_cast __symmap__["foo0"]
foo1 = auto_cast __symmap__["foo1"]
foo2 = auto_cast __symmap__["foo2"]
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }











Y : int : 123
Z :: Y + 7

























X :: "what"





















@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	odds = []int{1, 3, 5}
	 fmt.println("odds =", odds)
	 fmt.println("sum(..odds) =", sum(..odds))
	 fmt.println("sum(..odds, init_value = 5) =", sum(..odds, init_value = 5))
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
add_ints :: proc(a, b: int) -> int {
    x := a + b
    fmt.println("add_ints", x)
    return x
}
add_floats :: proc(a, b: f32) -> f32 {
    x := a + b
    fmt.println("add_floats", x)
    return x
}
add_numbers :: proc(a: int, b: f32, c: u8) -> int {
    x := int(a) + int(b) + int(c)
    fmt.println("add_numbers", x)
    return x
}
add :: proc{add_ints, add_floats, add_numbers}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_46_104
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_dynamic_array: ^[dynamic]int
h: ^int
a: ^string
b: ^string
y: ^int
z: ^f64
some_array: ^[3]int
some_slice: ^[]int
odds: ^[]int
some_map: ^map[string]int
some_string: ^string
x: ^int
my_integer_variable: ^int
cond: ^bool
cond1: ^bool
cond2: ^bool
k: ^int
i: ^int
sum : proc(nums: ..int, init_value:= 0) -> (result: int) = nil
foo0 : proc() -> int = nil
foo1 : proc() -> (a: int) = nil
foo2 : proc() -> (a, b: int) = nil
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) add_ints :: proc(a, b: int) -> int {
    x := a + b
    fmt.println("add_ints", x)
    return x
}
@(export) add_floats :: proc(a, b: f32) -> f32 {
    x := a + b
    fmt.println("add_floats", x)
    return x
}
@(export) add_numbers :: proc(a: int, b: f32, c: u8) -> int {
    x := int(a) + int(b) + int(c)
    fmt.println("add_numbers", x)
    return x
}
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
odds = (cast(^[]int)__symmap__["odds"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_string = (cast(^string)__symmap__["some_string"])
x = (cast(^int)__symmap__["x"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
k = (cast(^int)__symmap__["k"])
i = (cast(^int)__symmap__["i"])
sum = auto_cast __symmap__["sum"]
foo0 = auto_cast __symmap__["foo0"]
foo1 = auto_cast __symmap__["foo1"]
foo2 = auto_cast __symmap__["foo2"]
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }











Y : int : 123
Z :: Y + 7


























X :: "what"




















add :: proc{add_ints, add_floats, add_numbers}

@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
add(int(1), int(2))
add(f32(1), f32(2))
add(int(1), f32(2), u8(3))

add(1, 2)     // untyped ints coerce to int tighter than f32
add(1.0, 2.0) // untyped floats coerce to f32 tighter than int
add(1, 2, 3)  // three parameters

// Ambiguous answers
// add(1.0, 2)
// add(1, 2.0)
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_46_105
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_dynamic_array: ^[dynamic]int
h: ^int
a: ^string
b: ^string
y: ^int
z: ^f64
some_array: ^[3]int
some_slice: ^[]int
odds: ^[]int
some_map: ^map[string]int
some_string: ^string
x: ^int
my_integer_variable: ^int
cond: ^bool
cond1: ^bool
cond2: ^bool
k: ^int
i: ^int
sum : proc(nums: ..int, init_value:= 0) -> (result: int) = nil
foo0 : proc() -> int = nil
foo1 : proc() -> (a: int) = nil
foo2 : proc() -> (a, b: int) = nil
add_ints : proc(a, b: int) -> int = nil
add_floats : proc(a, b: f32) -> f32 = nil
add_numbers : proc(a: int, b: f32, c: u8) -> int = nil
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
odds = (cast(^[]int)__symmap__["odds"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_string = (cast(^string)__symmap__["some_string"])
x = (cast(^int)__symmap__["x"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
k = (cast(^int)__symmap__["k"])
i = (cast(^int)__symmap__["i"])
sum = auto_cast __symmap__["sum"]
foo0 = auto_cast __symmap__["foo0"]
foo1 = auto_cast __symmap__["foo1"]
foo2 = auto_cast __symmap__["foo2"]
add_ints = auto_cast __symmap__["add_ints"]
add_floats = auto_cast __symmap__["add_floats"]
add_numbers = auto_cast __symmap__["add_numbers"]
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }











Y : int : 123
Z :: Y + 7
























add :: proc{add_ints, add_floats, add_numbers}



X :: "what"





















@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 add(int(1), int(2))
	 add(f32(1), f32(2))
	 add(int(1), f32(2), u8(3))
	 add(1, 2)
	 add(1.0, 2.0)
	 add(1, 2, 3)
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
Vector2 :: struct {
    x: f32,
    y: f32,
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_47_107
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_dynamic_array: ^[dynamic]int
h: ^int
a: ^string
b: ^string
y: ^int
z: ^f64
some_array: ^[3]int
some_slice: ^[]int
odds: ^[]int
some_map: ^map[string]int
some_string: ^string
x: ^int
my_integer_variable: ^int
cond: ^bool
cond1: ^bool
cond2: ^bool
k: ^int
i: ^int
sum : proc(nums: ..int, init_value:= 0) -> (result: int) = nil
foo0 : proc() -> int = nil
foo1 : proc() -> (a: int) = nil
foo2 : proc() -> (a, b: int) = nil
add_ints : proc(a, b: int) -> int = nil
add_floats : proc(a, b: f32) -> f32 = nil
add_numbers : proc(a: int, b: f32, c: u8) -> int = nil
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
odds = (cast(^[]int)__symmap__["odds"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_string = (cast(^string)__symmap__["some_string"])
x = (cast(^int)__symmap__["x"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
k = (cast(^int)__symmap__["k"])
i = (cast(^int)__symmap__["i"])
sum = auto_cast __symmap__["sum"]
foo0 = auto_cast __symmap__["foo0"]
foo1 = auto_cast __symmap__["foo1"]
foo2 = auto_cast __symmap__["foo2"]
add_ints = auto_cast __symmap__["add_ints"]
add_floats = auto_cast __symmap__["add_floats"]
add_numbers = auto_cast __symmap__["add_numbers"]
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }











Y : int : 123
Z :: Y + 7
























add :: proc{add_ints, add_floats, add_numbers}




X :: "what"




















Vector2 :: struct {
    x: f32,
    y: f32,
}

@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[ERROR] --- [2025-07-28 17:15:47] [test_notebooks.odin:20:test_error_handler()] [0;31m[JodinInterpreter] [0mPreprocessor_Error: C:/Code/jodin/src/interpreter/preprocessor.odin(329:35): 
[ERROR] --- [2025-07-28 17:15:47] [test_notebooks.odin:21:test_error_handler()] JOdin cannot infer the type of v. Please declare it explicitly.%!(EXTRA Pos{file = "C:\\Code\\jodin\\.temp\\session_17_15_25\\cell_17_15_47_109\\cell_17_15_47_109.odin", offset = 26, line = 1, column = 1})
[ERROR] --- [2025-07-28 17:15:47] [test_notebooks.odin:59:test_notebook()] Cell 109 failed with error: Preprocessor_Error.
[ERROR] --- [2025-07-28 17:15:47] [test_notebooks.odin:20:test_error_handler()] [0;31m[JodinInterpreter] [0mPreprocessor_Error: C:/Code/jodin/src/interpreter/preprocessor.odin(329:35): 
[ERROR] --- [2025-07-28 17:15:47] [test_notebooks.odin:21:test_error_handler()] JOdin cannot infer the type of p. Please declare it explicitly.%!(EXTRA Pos{file = "C:\\Code\\jodin\\.temp\\session_17_15_25\\cell_17_15_47_111\\cell_17_15_47_111.odin", offset = 44, line = 2, column = 1})
[ERROR] --- [2025-07-28 17:15:47] [test_notebooks.odin:59:test_notebook()] Cell 111 failed with error: Preprocessor_Error.
[1;34m[CellContent]----------------------------------------
Vector3 :: struct {
    x, y, z: f32,
}
v: Vector3
v = Vector3{} // Zero value
v = Vector3{1, 4, 9}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_47_114
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_dynamic_array: ^[dynamic]int
h: ^int
a: ^string
b: ^string
y: ^int
z: ^f64
some_array: ^[3]int
some_slice: ^[]int
odds: ^[]int
some_map: ^map[string]int
some_string: ^string
x: ^int
my_integer_variable: ^int
cond: ^bool
cond1: ^bool
cond2: ^bool
k: ^int
i: ^int
v: Vector3
sum : proc(nums: ..int, init_value:= 0) -> (result: int) = nil
foo0 : proc() -> int = nil
foo1 : proc() -> (a: int) = nil
foo2 : proc() -> (a, b: int) = nil
add_ints : proc(a, b: int) -> int = nil
add_floats : proc(a, b: f32) -> f32 = nil
add_numbers : proc(a: int, b: f32, c: u8) -> int = nil
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) __update_symmap__:: proc() {
__symmap__["v"] = auto_cast &v
}
@(export) __apply_symmap__:: proc() {
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
odds = (cast(^[]int)__symmap__["odds"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_string = (cast(^string)__symmap__["some_string"])
x = (cast(^int)__symmap__["x"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
k = (cast(^int)__symmap__["k"])
i = (cast(^int)__symmap__["i"])
sum = auto_cast __symmap__["sum"]
foo0 = auto_cast __symmap__["foo0"]
foo1 = auto_cast __symmap__["foo1"]
foo2 = auto_cast __symmap__["foo2"]
add_ints = auto_cast __symmap__["add_ints"]
add_floats = auto_cast __symmap__["add_floats"]
add_numbers = auto_cast __symmap__["add_numbers"]
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }






Vector2 :: struct {
    x: f32,
    y: f32,
}






Y : int : 123
Z :: Y + 7
























add :: proc{add_ints, add_floats, add_numbers}




X :: "what"




















Vector3 :: struct {
    x, y, z: f32,
}

@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 v = Vector3{}
	 v = Vector3{1, 4, 9}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[1;34m[CellContent]----------------------------------------
v = Vector3{z=1, y=2}
assert(v.x == 0)
assert(v.y == 2)
assert(v.z == 1)
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_47_116
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_dynamic_array: ^[dynamic]int
h: ^int
a: ^string
b: ^string
y: ^int
z: ^f64
some_array: ^[3]int
some_slice: ^[]int
odds: ^[]int
some_map: ^map[string]int
some_string: ^string
x: ^int
my_integer_variable: ^int
cond: ^bool
cond1: ^bool
cond2: ^bool
v: ^Vector3
k: ^int
i: ^int
sum : proc(nums: ..int, init_value:= 0) -> (result: int) = nil
foo0 : proc() -> int = nil
foo1 : proc() -> (a: int) = nil
foo2 : proc() -> (a, b: int) = nil
add_ints : proc(a, b: int) -> int = nil
add_floats : proc(a, b: f32) -> f32 = nil
add_numbers : proc(a: int, b: f32, c: u8) -> int = nil
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
odds = (cast(^[]int)__symmap__["odds"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_string = (cast(^string)__symmap__["some_string"])
x = (cast(^int)__symmap__["x"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
v = (cast(^Vector3)__symmap__["v"])
k = (cast(^int)__symmap__["k"])
i = (cast(^int)__symmap__["i"])
sum = auto_cast __symmap__["sum"]
foo0 = auto_cast __symmap__["foo0"]
foo1 = auto_cast __symmap__["foo1"]
foo2 = auto_cast __symmap__["foo2"]
add_ints = auto_cast __symmap__["add_ints"]
add_floats = auto_cast __symmap__["add_floats"]
add_numbers = auto_cast __symmap__["add_numbers"]
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }






Vector2 :: struct {
    x: f32,
    y: f32,
}






Y : int : 123
Z :: Y + 7
























add :: proc{add_ints, add_floats, add_numbers}




X :: "what"









Vector3 :: struct {
    x, y, z: f32,
}













@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	 v^ = Vector3{z^=1, y^=2}
	 assert(v^.x^ == 0)
	 assert(v^.y^ == 2)
	 assert(v^.z^ == 1)
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:20:test_error_handler()] [0;31m[JodinInterpreter] [0mCompiler_Error: C:/Code/jodin/src/interpreter/cell.odin(259:10): 
[1;34m[CellContent]----------------------------------------
[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:21:test_error_handler()] C:/Code/jodin/.temp/session_17_15_25/cell_17_15_47_116/cell_17_15_47_116.odin(172:17) Error: Invalid field name 'z^' in structure literal 
	v^ = Vector3%!(MISSING ARGUMENT)%!(MISSING CLOSE BRACE)^=1, y^=2} 
	              ^~^ 
C:/Code/jodin/.temp/session_17_15_25/cell_17_15_47_116/cell_17_15_47_116.odin(172:23) Error: Invalid field name 'y^' in structure literal 
	v^ = Vector3%!(MISSING ARGUMENT)%!(MISSING CLOSE BRACE)^=1, y^=2} 
	                    ^~^ 
C:/Code/jodin/.temp/session_17_15_25/cell_17_15_47_116/cell_17_15_47_116.odin(173:11) Error: Cannot dereference 'v^.x' of type 'f32' 
	assert(v^.x^ == 0) 
	        ^~^ 
C:/Code/jodin/.temp/session_17_15_25/cell_17_15_47_116/cell_17_15_47_116.odin(174:11) Error: Cannot dereference 'v^.y' of type 'f32' 
	assert(v^.y^ == 2) 
	        ^~^ 
C:/Code/jodin/.temp/session_17_15_25/cell_17_15_47_116/cell_17_15_47_116.odin(175:11) Error: Cannot dereference 'v^.z' of type 'f32' 
	assert(v^.z^ == 1) 
	        ^~^ 

[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:59:test_notebook()] Cell 116 failed with error: Compiler_Error.
a :: struct #align(4)  {} // align to 4 bytes
b :: struct #packed    {} // remove padding between fields
c :: struct #raw_union {} // all fields share the same offset (0). This is the same as C's union
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_48_118
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_dynamic_array: ^[dynamic]int
h: ^int
a: ^string
b: ^string
y: ^int
z: ^f64
some_array: ^[3]int
some_slice: ^[]int
odds: ^[]int
some_map: ^map[string]int
some_string: ^string
x: ^int
my_integer_variable: ^int
cond: ^bool
cond1: ^bool
cond2: ^bool
v: ^Vector3
k: ^int
i: ^int
sum : proc(nums: ..int, init_value:= 0) -> (result: int) = nil
foo0 : proc() -> int = nil
foo1 : proc() -> (a: int) = nil
foo2 : proc() -> (a, b: int) = nil
add_ints : proc(a, b: int) -> int = nil
add_floats : proc(a, b: f32) -> f32 = nil
add_numbers : proc(a: int, b: f32, c: u8) -> int = nil
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
odds = (cast(^[]int)__symmap__["odds"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_string = (cast(^string)__symmap__["some_string"])
x = (cast(^int)__symmap__["x"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
v = (cast(^Vector3)__symmap__["v"])
k = (cast(^int)__symmap__["k"])
i = (cast(^int)__symmap__["i"])
sum = auto_cast __symmap__["sum"]
foo0 = auto_cast __symmap__["foo0"]
foo1 = auto_cast __symmap__["foo1"]
foo2 = auto_cast __symmap__["foo2"]
add_ints = auto_cast __symmap__["add_ints"]
add_floats = auto_cast __symmap__["add_floats"]
add_numbers = auto_cast __symmap__["add_numbers"]
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }






Vector2 :: struct {
    x: f32,
    y: f32,
}






Y : int : 123
Z :: Y + 7
























add :: proc{add_ints, add_floats, add_numbers}




X :: "what"









Vector3 :: struct {
    x, y, z: f32,
}












a :: struct #align(4)  {}
b :: struct #packed    {}
c :: struct #raw_union {}

@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:20:test_error_handler()] [0;31m[JodinInterpreter] [0mCompiler_Error: C:/Code/jodin/src/interpreter/cell.odin(259:10): 
[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:21:test_error_handler()] C:/Code/jodin/.temp/session_17_15_25/cell_17_15_48_118/cell_17_15_48_118.odin(154:1) Error: Redeclaration of 'a' in this scope 
	at C:/Code/jodin/.temp/session_17_15_25/cell_17_15_48_118/cell_17_15_48_118.odin(21:1) 
	a :: struct #align(4)  %!(MISSING ARGUMENT) 
	^ 
C:/Code/jodin/.temp/session_17_15_25/cell_17_15_48_118/cell_17_15_48_118.odin(155:1) Error: Redeclaration of 'b' in this scope 
	at C:/Code/jodin/.temp/session_17_15_25/cell_17_15_48_118/cell_17_15_48_118.odin(22:1) 
	b :: struct #packed    %!(MISSING ARGUMENT) 
	^ 

[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:59:test_notebook()] Cell 118 failed with error: Compiler_Error.
[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:20:test_error_handler()] [0;31m[JodinInterpreter] [0mPreprocessor_Error: C:/Code/jodin/src/interpreter/preprocessor.odin(378:11): 
[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:21:test_error_handler()] Undandled declaration switch v^ in val {
	case int:  fmt.println("int",  v^)
	case bool: fmt.println("bool", v^)
	case:      fmt.println("nil")
	} of type Any_Stmt.
[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:59:test_notebook()] Cell 120 failed with error: Preprocessor_Error.
[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:20:test_error_handler()] [0;31m[JodinInterpreter] [0mPreprocessor_Error: C:/Code/jodin/src/interpreter/preprocessor.odin(378:11): 
[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:21:test_error_handler()] Undandled declaration switch v^ in val {
	case int:  fmt.println("int",  v^)
	case bool: fmt.println("bool", v^)
	case:      fmt.println("nil") of type Any_Stmt.
[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:59:test_notebook()] Cell 122 failed with error: Preprocessor_Error.
[1;34m[CellContent]----------------------------------------
Vector3 :: distinct [3]f32
Quaternion :: distinct quaternion128
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_48_125
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_dynamic_array: ^[dynamic]int
h: ^int
a: ^string
b: ^string
y: ^int
z: ^f64
some_array: ^[3]int
some_slice: ^[]int
odds: ^[]int
some_map: ^map[string]int
some_string: ^string
x: ^int
my_integer_variable: ^int
cond: ^bool
cond1: ^bool
cond2: ^bool
v: ^Vector3
k: ^int
i: ^int
sum : proc(nums: ..int, init_value:= 0) -> (result: int) = nil
foo0 : proc() -> int = nil
foo1 : proc() -> (a: int) = nil
foo2 : proc() -> (a, b: int) = nil
add_ints : proc(a, b: int) -> int = nil
add_floats : proc(a, b: f32) -> f32 = nil
add_numbers : proc(a: int, b: f32, c: u8) -> int = nil
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
odds = (cast(^[]int)__symmap__["odds"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_string = (cast(^string)__symmap__["some_string"])
x = (cast(^int)__symmap__["x"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
v = (cast(^Vector3)__symmap__["v"])
k = (cast(^int)__symmap__["k"])
i = (cast(^int)__symmap__["i"])
sum = auto_cast __symmap__["sum"]
foo0 = auto_cast __symmap__["foo0"]
foo1 = auto_cast __symmap__["foo1"]
foo2 = auto_cast __symmap__["foo2"]
add_ints = auto_cast __symmap__["add_ints"]
add_floats = auto_cast __symmap__["add_floats"]
add_numbers = auto_cast __symmap__["add_numbers"]
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }






Vector2 :: struct {
    x: f32,
    y: f32,
}






Y : int : 123
Z :: Y + 7
























add :: proc{add_ints, add_floats, add_numbers}




X :: "what"









Vector3 :: struct {
    x, y, z: f32,
}












Vector3 :: distinct [3]f32
Quaternion :: distinct quaternion128

@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:20:test_error_handler()] [0;31m[JodinInterpreter] [0mCompiler_Error: C:/Code/jodin/src/interpreter/cell.odin(259:10): 
[1;34m[CellContent]----------------------------------------
{
    Entity :: struct {
        id:          u64,
        name:        string,
        position:    Vector3,
        orientation: Quaternion,
    
        derived: any,
    }
    
    Frog :: struct {
        using entity: Entity,
        jump_height:  f32,
    }
    
    Monster :: struct {
        using entity: Entity,
        is_robot:     bool,
        is_zombie:    bool,
    }
    
    // See `parametric_polymorphism` procedure for details
    new_entity :: proc($T: typeid) -> ^Entity {
        t := new(T)
        t.derived = t^
        return t
    }
    
    entity := new_entity(Monster)
    
    switch e in entity.derived {
    case Frog:
        fmt.println("Ribbit")
    case Monster:
        if e.is_robot  { fmt.println("Robotic") }
        if e.is_zombie { fmt.println("Grrrr!")  }
        fmt.println("I'm a monster")
    }
}
-----------------------------------------------------[0m
[1;34m[CellSource]-----------------------------------------

package cell_17_15_48_126
import "shared:jodin"
import "core:io"
import "core:os"
import "core:sync"
import "core:fmt"
import "core:mem"
import "core:thread"
import "core:time"
import "core:reflect"
import "base:runtime"
import "base:intrinsics"
import "core:math/big"
@(export) __cell__: ^jodin.Cell = nil
__data_mutex__: ^sync.Ticket_Mutex = nil
__stdout__, __stderr__, __iopub__, __original_stdout__, __original_stderr__: os.Handle
__symmap__: ^map[string]rawptr = nil
some_dynamic_array: ^[dynamic]int
h: ^int
a: ^string
b: ^string
y: ^int
z: ^f64
some_array: ^[3]int
some_slice: ^[]int
odds: ^[]int
some_map: ^map[string]int
some_string: ^string
x: ^int
my_integer_variable: ^int
cond: ^bool
cond1: ^bool
cond2: ^bool
v: ^Vector3
k: ^int
i: ^int
sum : proc(nums: ..int, init_value:= 0) -> (result: int) = nil
foo0 : proc() -> int = nil
foo1 : proc() -> (a: int) = nil
foo2 : proc() -> (a, b: int) = nil
add_ints : proc(a, b: int) -> int = nil
add_floats : proc(a, b: f32) -> f32 = nil
add_numbers : proc(a: int, b: f32, c: u8) -> int = nil
one_angry_dwarf : proc() -> int = nil
one_step : proc() = nil
beyond : proc() = nil
@(export) __update_symmap__:: proc() {
}
@(export) __apply_symmap__:: proc() {
some_dynamic_array = (cast(^[dynamic]int)__symmap__["some_dynamic_array"])
h = (cast(^int)__symmap__["h"])
a = (cast(^string)__symmap__["a"])
b = (cast(^string)__symmap__["b"])
y = (cast(^int)__symmap__["y"])
z = (cast(^f64)__symmap__["z"])
some_array = (cast(^[3]int)__symmap__["some_array"])
some_slice = (cast(^[]int)__symmap__["some_slice"])
odds = (cast(^[]int)__symmap__["odds"])
some_map = (cast(^map[string]int)__symmap__["some_map"])
some_string = (cast(^string)__symmap__["some_string"])
x = (cast(^int)__symmap__["x"])
my_integer_variable = (cast(^int)__symmap__["my_integer_variable"])
cond = (cast(^bool)__symmap__["cond"])
cond1 = (cast(^bool)__symmap__["cond1"])
cond2 = (cast(^bool)__symmap__["cond2"])
v = (cast(^Vector3)__symmap__["v"])
k = (cast(^int)__symmap__["k"])
i = (cast(^int)__symmap__["i"])
sum = auto_cast __symmap__["sum"]
foo0 = auto_cast __symmap__["foo0"]
foo1 = auto_cast __symmap__["foo1"]
foo2 = auto_cast __symmap__["foo2"]
add_ints = auto_cast __symmap__["add_ints"]
add_floats = auto_cast __symmap__["add_floats"]
add_numbers = auto_cast __symmap__["add_numbers"]
one_angry_dwarf = auto_cast __symmap__["one_angry_dwarf"]
one_step = auto_cast __symmap__["one_step"]
beyond = auto_cast __symmap__["beyond"]
}
exit:: proc() { __cell__.session.exit = true }






Vector2 :: struct {
    x: f32,
    y: f32,
}






Y : int : 123
Z :: Y + 7
























add :: proc{add_ints, add_floats, add_numbers}




X :: "what"









Vector3 :: struct {
    x, y, z: f32,
}













@(export) __init__:: proc(_cell: ^jodin.Cell, _stdout: os.Handle, _stderr: os.Handle, _iopub: os.Handle, _symmap: ^map[string]rawptr) {
	__data_mutex__ = &_cell.session.data_mutex
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	__cell__ = _cell
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	__original_stdout__ = os.stdout
	__original_stderr__ = os.stderr
	__stdout__ = _stdout; os.stdout = __stdout__
	__stderr__ = _stderr; os.stderr = __stderr__
	__iopub__ = _iopub
	__symmap__ = _symmap
}
@(export) __main__:: proc() {
	sync.ticket_mutex_lock(__data_mutex__); defer sync.ticket_mutex_unlock(__data_mutex__)
	sync.mutex_lock(&__cell__.mutex); defer sync.mutex_unlock(&__cell__.mutex)
	context = __cell__.cell_context
	{
    Entity :: struct {
        id:          u64,
        name:        string,
        position:    Vector3,
        orientation: Quaternion,
    
        derived: any,
    }
    
    Frog :: struct {
        using entity: Entity,
        jump_height:  f32,
    }
    
    Monster :: struct {
        using entity: Entity,
        is_robot:     bool,
        is_zombie:    bool,
    }
    
    // See `parametric_polymorphism` procedure for details
    new_entity :: proc($T: typeid) -> ^Entity {
        t := new(T)
        t.derived = t^
        return t
    }
    
    entity := new_entity(Monster)
    
    switch e in entity.derived {
    case Frog:
        fmt.println("Ribbit")
    case Monster:
        if e.is_robot  { fmt.println("Robotic") }
        if e.is_zombie { fmt.println("Grrrr!")  }
        fmt.println("I'm a monster")
    }
}
	os.stdout = __original_stdout__
	os.stderr = __original_stderr__
}

-----------------------------------------------------[0m
[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:21:test_error_handler()] C:/Code/jodin/.temp/session_17_15_25/cell_17_15_48_125/cell_17_15_48_125.odin(154:1) Error: Redeclaration of 'Vector3' in this scope 
	at C:/Code/jodin/.temp/session_17_15_25/cell_17_15_48_125/cell_17_15_48_125.odin(139:1) 
	Vector3 :: distinct [3]f32 
	^ 

[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:59:test_notebook()] Cell 125 failed with error: Compiler_Error.
[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:20:test_error_handler()] [0;31m[JodinInterpreter] [0mCompiler_Error: C:/Code/jodin/src/interpreter/cell.odin(259:10): 
[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:21:test_error_handler()] C:/Code/jodin/.temp/session_17_15_25/cell_17_15_48_126/cell_17_15_48_126.odin(177:22) Error: Undeclared name: Quaternion 
	orientation: Quaternion, 
	             ^~~~~~~~~^ 

[ERROR] --- [2025-07-28 17:15:48] [test_notebooks.odin:59:test_notebook()] Cell 126 failed with error: Compiler_Error.
C:/Code/jodin/src/interpreter/preprocessor.odin(79:23) Invalid slice indices 0:2 is out of range 0..<0
